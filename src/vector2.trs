//! Vector of 2 elements.

#![no_std]

#[cfg(any(test, feature = "std"))]
#[cfg_attr(test, macro_use)]
extern crate std;

use core::fmt;
#[cfg(test)]
use core::hash;
use core::iter::{Product, Sum};
use core::ops::{Add, Div, Mul, Neg, Rem, Sub};
use core::str::FromStr;
#[cfg(feature = "std")]
use std::error::Error;

use num_traits::{Inv, MulAdd, Num, Pow, Signed, Zero};

#[cfg(any(feature = "std", feature = "libm"))]
use num_traits::float::Float;
use num_traits::float::FloatCore;

// mod cast;
// mod pow;
// 
// #[cfg(feature = "rand")]
// mod crand;
// #[cfg(feature = "rand")]
// pub use crate::crand::Vector2Distribution;

/// A vector2 object in Cartesian form.
///
/// ## Representation and Foreign Function Interface Compatibility
///
/// `Vector2<T>` is memory layout compatible with an array `[T; 2]`.
///
/// Note that `Vector2<F>` where F is a floating point type is **only** memory
/// layout compatible with C's complex types, **not** necessarily calling
/// convention compatible.  This means that for FFI you can only pass
/// `Vector2<F>` behind a pointer, not as a value.
///
/// ## Examples
///
/// Example of extern function declaration.
///
/// ```
/// use num_vector2::Vector2;
/// use std::os::raw::c_int;
///
/// extern "C" {
///     fn zaxpy_(n: *const c_int, alpha: *const Vector2<f64>,
///               x: *const Vector2<f64>, incx: *const c_int,
///               y: *mut Vector2<f64>, incy: *const c_int);
/// }
/// ```
#[derive(PartialEq, Eq, Copy, Clone, Hash, Debug, Default)]
#[repr(C)]
pub struct Vector2<T> {
    /// Real portion of the vector2 object
    pub x_: T,
    /// Imaginary portion of the vector2 object
    pub y_: T,
}

pub type Vector232 = Vector2<f32>;
pub type Vector264 = Vector2<f64>;

impl<T> Vector2<T> {
    /// Create a new Vector2
    #[inline]
    pub const fn new(x_: T, y_: T) -> Self {
        Vector2 { x_, y_ }
    }
}

impl<T: Clone + Num> Vector2<T> {
    /// Returns the square of the norm (since `T` doesn't necessarily
    /// have a sqrt function), i.e. `x_^2 + y_^2`.
    #[inline]
    pub fn norm_sqr(&self) -> T {
        self.x_.clone() * self.x_.clone() + self.y_.clone() * self.y_.clone()
    }

    /// Multiplies `self` by the scalar `t`.
    #[inline]
    pub fn scale(&self, t: T) -> Self {
        Self::new(self.x_.clone() * t.clone(), self.y_.clone() * t)
    }

    /// Divides `self` by the scalar `t`.
    #[inline]
    pub fn unscale(&self, t: T) -> Self {
        Self::new(self.x_.clone() / t.clone(), self.y_.clone() / t)
    }
}

impl<T: Clone + Signed> Vector2<T> {
    /// Returns the L1 norm `|x_| + |y_|` -- the [Manhattan distance] from the origin.
    ///
    /// [Manhattan distance]: https://en.wikipedia.org/wiki/Taxicab_geometry
    #[inline]
    pub fn l1_norm(&self) -> T {
        self.x_.abs() + self.y_.abs()
    }
}


macro_rules! forward_xf_xf_binop {
    (impl $imp:ident, $method:ident) => {
        impl<'a, 'b, T: Clone + Num> $imp<&'b Vector2<T>> for &'a Vector2<T> {
            type Output = Vector2<T>;

            #[inline]
            fn $method(self, other: &Vector2<T>) -> Self::Output {
                self.clone().$method(other.clone())
            }
        }
    };
}

macro_rules! forward_xf_val_binop {
    (impl $imp:ident, $method:ident) => {
        impl<'a, T: Clone + Num> $imp<Vector2<T>> for &'a Vector2<T> {
            type Output = Vector2<T>;

            #[inline]
            fn $method(self, other: Vector2<T>) -> Self::Output {
                self.clone().$method(other)
            }
        }
    };
}

macro_rules! forward_val_xf_binop {
    (impl $imp:ident, $method:ident) => {
        impl<'a, T: Clone + Num> $imp<&'a Vector2<T>> for Vector2<T> {
            type Output = Vector2<T>;

            #[inline]
            fn $method(self, other: &Vector2<T>) -> Self::Output {
                self.$method(other.clone())
            }
        }
    };
}

macro_rules! forward_all_binop {
    (impl $imp:ident, $method:ident) => {
        forward_xf_xf_binop!(impl $imp, $method);
        forward_xf_val_binop!(impl $imp, $method);
        forward_val_xf_binop!(impl $imp, $method);
    };
}

// arithmetic
forward_all_binop!(impl Add, add);

// (a, b) + (c, d) == (a + c), (b + d)
impl<T: Clone + Num> Add<Vector2<T>> for Vector2<T> {
    type Output = Self;

    #[inline]
    fn add(self, other: Self) -> Self::Output {
        Self::Output::new(self.x_ + other.x_, self.y_ + other.y_)
    }
}

forward_all_binop!(impl Sub, sub);

// (a, b) - (c, d) == (a - c), (b - d)
impl<T: Clone + Num> Sub<Vector2<T>> for Vector2<T> {
    type Output = Self;

    #[inline]
    fn sub(self, other: Self) -> Self::Output {
        Self::Output::new(self.x_ - other.x_, self.y_ - other.y_)
    }
}

// Op Assign

mod opassign {
    use core::ops::{AddAssign, SubAssign};

    use num_traits::{NumAssign};

    use crate::Vector2;

    impl<T: Clone + NumAssign> AddAssign for Vector2<T> {
        fn add_assign(&mut self, other: Self) {
            self.x_ += other.x_;
            self.y_ += other.y_;
        }
    }

    impl<T: Clone + NumAssign> SubAssign for Vector2<T> {
        fn sub_assign(&mut self, other: Self) {
            self.x_ -= other.x_;
            self.y_ -= other.y_;
        }
    }

    impl<T: Clone + NumAssign> AddAssign<T> for Vector2<T> {
        fn add_assign(&mut self, other: T) {
            self.x_ += other;
        }
    }

    impl<T: Clone + NumAssign> SubAssign<T> for Vector2<T> {
        fn sub_assign(&mut self, other: T) {
            self.x_ -= other;
        }
    }

    impl<T: Clone + NumAssign> MulAssign<T> for Vector2<T> {
        fn mul_assign(&mut self, other: T) {
            self.x_ *= other.clone();
            self.y_ *= other;
        }
    }

    impl<T: Clone + NumAssign> DivAssign<T> for Vector2<T> {
        fn div_assign(&mut self, other: T) {
            self.x_ /= other.clone();
            self.y_ /= other;
        }
    }

    macro_rules! forward_op_assign {
        (impl $imp:ident, $method:ident) => {
            impl<'a, T: Clone + NumAssign> $imp<&'a Vector2<T>> for Vector2<T> {
                #[inline]
                fn $method(&mut self, other: &Self) {
                    self.$method(other.clone())
                }
            }
            impl<'a, T: Clone + NumAssign> $imp<&'a T> for Vector2<T> {
                #[inline]
                fn $method(&mut self, other: &T) {
                    self.$method(other.clone())
                }
            }
        };
    }

    forward_op_assign!(impl AddAssign, add_assign);
    forward_op_assign!(impl SubAssign, sub_assign);
    forward_op_assign!(impl MulAssign, mul_assign);
    forward_op_assign!(impl DivAssign, div_assign);
}

impl<T: Clone + Num + Neg<Output = T>> Neg for Vector2<T> {
    type Output = Self;

    #[inline]
    fn neg(self) -> Self::Output {
        Self::Output::new(-self.x_, -self.y_)
    }
}

impl<'a, T: Clone + Num + Neg<Output = T>> Neg for &'a Vector2<T> {
    type Output = Vector2<T>;

    #[inline]
    fn neg(self) -> Self::Output {
        -self.clone()
    }
}

macro_rules! real_arithmetic {
    (@forward $imp:ident::$method:ident for $($real:ident),*) => (
        impl<'a, T: Clone + Num> $imp<&'a T> for Vector2<T> {
            type Output = Vector2<T>;

            #[inline]
            fn $method(self, other: &T) -> Self::Output {
                self.$method(other.clone())
            }
        }
        impl<'a, T: Clone + Num> $imp<T> for &'a Vector2<T> {
            type Output = Vector2<T>;

            #[inline]
            fn $method(self, other: T) -> Self::Output {
                self.clone().$method(other)
            }
        }
        impl<'a, 'b, T: Clone + Num> $imp<&'a T> for &'b Vector2<T> {
            type Output = Vector2<T>;

            #[inline]
            fn $method(self, other: &T) -> Self::Output {
                self.clone().$method(other.clone())
            }
        }
        $(
            impl<'a> $imp<&'a Vector2<$real>> for $real {
                type Output = Vector2<$real>;

                #[inline]
                fn $method(self, other: &Vector2<$real>) -> Vector2<$real> {
                    self.$method(other.clone())
                }
            }
            impl<'a> $imp<Vector2<$real>> for &'a $real {
                type Output = Vector2<$real>;

                #[inline]
                fn $method(self, other: Vector2<$real>) -> Vector2<$real> {
                    self.clone().$method(other)
                }
            }
            impl<'a, 'b> $imp<&'a Vector2<$real>> for &'b $real {
                type Output = Vector2<$real>;

                #[inline]
                fn $method(self, other: &Vector2<$real>) -> Vector2<$real> {
                    self.clone().$method(other.clone())
                }
            }
        )*
    );
    ($($real:ident),*) => (
        real_arithmetic!(@forward Mul::mul for $($real),*);
        real_arithmetic!(@forward Div::div for $($real),*);
        real_arithmetic!(@forward Rem::rem for $($real),*);

        $(
            impl Mul<Vector2<$real>> for $real {
                type Output = Vector2<$real>;

                #[inline]
                fn mul(self, other: Vector2<$real>) -> Self::Output {
                    Self::Output::new(self * other.x_, self * other.y_)
                }
            }

        )*
    );
}

impl<T: Clone + Num> Mul<T> for Vector2<T> {
    type Output = Vector2<T>;

    #[inline]
    fn mul(self, other: T) -> Self::Output {
        Self::Output::new(self.x_ * other.clone(), self.y_ * other)
    }
}

impl<T: Clone + Num> Div<T> for Vector2<T> {
    type Output = Self;

    #[inline]
    fn div(self, other: T) -> Self::Output {
        Self::Output::new(self.x_ / other.clone(), self.y_ / other)
    }
}

impl<T: Clone + Num> Rem<T> for Vector2<T> {
    type Output = Vector2<T>;

    #[inline]
    fn rem(self, other: T) -> Self::Output {
        Self::Output::new(self.x_ % other.clone(), self.y_ % other)
    }
}

real_arithmetic!(usize, u8, u16, u32, u64, u128, isize, i8, i16, i32, i64, i128, f32, f64);

// constants
impl<T: Clone + Num> Zero for Vector2<T> {
    #[inline]
    fn zero() -> Self {
        Self::new(Zero::zero(), Zero::zero())
    }

    #[inline]
    fn is_zero(&self) -> bool {
        self.x_.is_zero() && self.y_.is_zero()
    }

    #[inline]
    fn set_zero(&mut self) {
        self.x_.set_zero();
        self.y_.set_zero();
    }
}

macro_rules! write_vector2 {
    ($f:ident, $t:expr, $prefix:expr, $x_:expr, $y_:expr, $T:ident) => {{
        let abs_x = if $x_ < Zero::zero() {
            $T::zero() - $x_.clone()
        } else {
            $x_.clone()
        };
        let abs_y = if $y_ < Zero::zero() {
            $T::zero() - $y_.clone()
        } else {
            $y_.clone()
        };

        return if let Some(prec) = $f.precision() {
            fmt_x_y(
                $f,
                $x_ < $T::zero(),
                $y_ < $T::zero(),
                format_args!(concat!("{:.1$", $t, "}"), abs_x, prec),
                format_args!(concat!("{:.1$", $t, "}"), abs_y, prec),
            )
        } else {
            fmt_x_y(
                $f,
                $x_ < $T::zero(),
                $y_ < $T::zero(),
                format_args!(concat!("{:", $t, "}"), abs_x),
                format_args!(concat!("{:", $t, "}"), abs_y),
            )
        };

        fn fmt_x_y(
            f: &mut fmt::Formatter<'_>,
            re_neg: bool,
            im_neg: bool,
            real: fmt::Arguments<'_>,
            imag: fmt::Arguments<'_>,
        ) -> fmt::Result {
            let prefix = if f.alternate() { $prefix } else { "" };
            let sign = if re_neg {
                "-"
            } else if f.sign_plus() {
                "+"
            } else {
                ""
            };

            if im_neg {
                fmt_vector2(
                    f,
                    format_args!(
                        "{}{pre}{x_}-{pre}{y_}i",
                        sign,
                        x_ = real,
                        y_ = imag,
                        pre = prefix
                    ),
                )
            } else {
                fmt_vector2(
                    f,
                    format_args!(
                        "{}{pre}{x_}+{pre}{y_}i",
                        sign,
                        x_ = real,
                        y_ = imag,
                        pre = prefix
                    ),
                )
            }
        }

        #[cfg(feature = "std")]
        // Currently, we can only apply width using an intermediate `String` (and thus `std`)
        fn fmt_vector2(f: &mut fmt::Formatter<'_>, complex: fmt::Arguments<'_>) -> fmt::Result {
            use std::string::ToString;
            if let Some(width) = f.width() {
                write!(f, "{0: >1$}", complex.to_string(), width)
            } else {
                write!(f, "{}", complex)
            }
        }

        #[cfg(not(feature = "std"))]
        fn fmt_vector2(f: &mut fmt::Formatter<'_>, complex: fmt::Arguments<'_>) -> fmt::Result {
            write!(f, "{}", complex)
        }
    }};
}

// string conversions
impl<T> fmt::Display for Vector2<T>
where
    T: fmt::Display + Num + PartialOrd + Clone,
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write_vector2!(f, "", "", self.x_, self.y_, T)
    }
}

impl<T> fmt::LowerExp for Vector2<T>
where
    T: fmt::LowerExp + Num + PartialOrd + Clone,
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write_vector2!(f, "e", "", self.x_, self.y_, T)
    }
}

impl<T> fmt::UpperExp for Vector2<T>
where
    T: fmt::UpperExp + Num + PartialOrd + Clone,
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write_vector2!(f, "E", "", self.x_, self.y_, T)
    }
}

impl<T> fmt::LowerHex for Vector2<T>
where
    T: fmt::LowerHex + Num + PartialOrd + Clone,
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write_vector2!(f, "x", "0x", self.x_, self.y_, T)
    }
}

impl<T> fmt::UpperHex for Vector2<T>
where
    T: fmt::UpperHex + Num + PartialOrd + Clone,
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write_vector2!(f, "X", "0x", self.x_, self.y_, T)
    }
}

impl<T> fmt::Octal for Vector2<T>
where
    T: fmt::Octal + Num + PartialOrd + Clone,
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write_vector2!(f, "o", "0o", self.x_, self.y_, T)
    }
}

impl<T> fmt::Binary for Vector2<T>
where
    T: fmt::Binary + Num + PartialOrd + Clone,
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write_vector2!(f, "b", "0b", self.x_, self.y_, T)
    }
}

#[allow(deprecated)] // `trim_left_matches` and `trim_right_matches` since 1.33
fn from_str_generic<T, E, F>(s: &str, from: F) -> Result<Vector2<T>, ParseVector2Error<E>>
where
    F: Fn(&str) -> Result<T, E>,
    T: Clone + Num,
{
    let imag = match s.rfind('j') {
        None => 'i',
        _ => 'j',
    };

    let mut neg_b = false;
    let mut a = s;
    let mut b = "";

    for (i, w) in s.as_bytes().windows(2).enumerate() {
        let p = w[0];
        let c = w[1];

        // ignore '+'/'-' if part of an exponent
        if (c == b'+' || c == b'-') && !(p == b'e' || p == b'E') {
            // trim whitespace around the separator
            a = &s[..=i].trim_right_matches(char::is_whitespace);
            b = &s[i + 2..].trim_left_matches(char::is_whitespace);
            neg_b = c == b'-';

            if b.is_empty() || (neg_b && b.starts_with('-')) {
                return Err(ParseVector2Error::new());
            }
            break;
        }
    }

    // split off real and imaginary parts
    if b.is_empty() {
        // input was either pure real or pure imaginary
        b = if a.ends_with(imag) { "0" } else { "0i" };
    }

    let x_;
    let neg_x;
    let y_;
    let neg_y;
    if a.ends_with(imag) {
        y_ = a;
        neg_y = false;
        x_ = b;
        neg_x = neg_b;
    } else if b.ends_with(imag) {
        x_ = a;
        neg_x = false;
        y_ = b;
        neg_y = neg_b;
    } else {
        return Err(ParseVector2Error::new());
    }

    // parse x_
    let x_ = from(x_).map_err(ParseVector2Error::from_error)?;
    let x_ = if neg_x { T::zero() - x_ } else { x_ };

    // pop imaginary unit off
    let mut y_ = &y_[..y_.len() - 1];
    // handle y_ == "i" or y_ == "-i"
    if y_.is_empty() || y_ == "+" {
        y_ = "1";
    } else if y_ == "-" {
        y_ = "-1";
    }

    // parse y_
    let y_ = from(y_).map_err(ParseVector2Error::from_error)?;
    let y_ = if neg_y { T::zero() - y_ } else { y_ };

    Ok(Vector2::new(x_, y_))
}

impl<T> FromStr for Vector2<T>
where
    T: FromStr + Num + Clone,
{
    type Err = ParseVector2Error<T::Err>;

    /// Parses `a +/- bi`; `ai +/- b`; `a`; or `bi` where `a` and `b` are of type `T`
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        from_str_generic(s, T::from_str)
    }
}

impl<T: Num + Clone> Num for Vector2<T> {
    type FromStrRadixErr = ParseVector2Error<T::FromStrRadixErr>;

    /// Parses `a +/- bi`; `ai +/- b`; `a`; or `bi` where `a` and `b` are of type `T`
    fn from_str_radix(s: &str, radix: u32) -> Result<Self, Self::FromStrRadixErr> {
        from_str_generic(s, |x| -> Result<T, T::FromStrRadixErr> {
            T::from_str_radix(x, radix)
        })
    }
}

impl<T: Num + Clone> Sum for Vector2<T> {
    fn sum<I>(iter: I) -> Self
    where
        I: Iterator<Item = Self>,
    {
        iter.fold(Self::zero(), |acc, c| acc + c)
    }
}

impl<'a, T: 'a + Num + Clone> Sum<&'a Vector2<T>> for Vector2<T> {
    fn sum<I>(iter: I) -> Self
    where
        I: Iterator<Item = &'a Vector2<T>>,
    {
        iter.fold(Self::zero(), |acc, c| acc + c)
    }
}

#[cfg(feature = "serde")]
impl<T> serde::Serialize for Vector2<T>
where
    T: serde::Serialize,
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        (&self.x_, &self.y_).serialize(serializer)
    }
}

#[cfg(feature = "serde")]
impl<'de, T> serde::Deserialize<'de> for Vector2<T>
where
    T: serde::Deserialize<'de> + Num + Clone,
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let (x_, y_) = serde::Deserialize::deserialize(deserializer)?;
        Ok(Self::new(x_, y_))
    }
}

#[derive(Debug, PartialEq)]
pub struct ParseVector2Error<E> {
    kind: Vector2ErrorKind<E>,
}

#[derive(Debug, PartialEq)]
enum Vector2ErrorKind<E> {
    ParseError(E),
    ExprError,
}

impl<E> ParseVector2Error<E> {
    fn new() -> Self {
        ParseVector2Error {
            kind: Vector2ErrorKind::ExprError,
        }
    }

    fn from_error(error: E) -> Self {
        ParseVector2Error {
            kind: Vector2ErrorKind::ParseError(error),
        }
    }
}

#[cfg(feature = "std")]
impl<E: Error> Error for ParseVector2Error<E> {
    #[allow(deprecated)]
    fn description(&self) -> &str {
        match self.kind {
            Vector2ErrorKind::ParseError(ref e) => e.description(),
            Vector2ErrorKind::ExprError => "invalid or unsupported complex expression",
        }
    }
}

impl<E: fmt::Display> fmt::Display for ParseVector2Error<E> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.kind {
            Vector2ErrorKind::ParseError(ref e) => e.fmt(f),
            Vector2ErrorKind::ExprError => "invalid or unsupported complex expression".fmt(f),
        }
    }
}

#[cfg(test)]
fn hash<T: hash::Hash>(x: &T) -> u64 {
    use std::collections::hash_map::RandomState;
    use std::hash::{BuildHasher, Hasher};
    let mut hasher = <RandomState as BuildHasher>::Hasher::new();
    x.hash(&mut hasher);
    hasher.finish()
}

#[cfg(test)]
mod test {
    #![allow(non_upper_case_globals)]

    use super::{Vector2, Vector264};
    use core::f64;
    use core::str::FromStr;

    use std::string::{String, ToString};

    use num_traits::{Num, Zero};

    pub const _0_0i: Vector264 = Vector2 { x_: 0.0, y_: 0.0 };
    pub const _1_0i: Vector264 = Vector2 { x_: 1.0, y_: 0.0 };
    pub const _1_1i: Vector264 = Vector2 { x_: 1.0, y_: 1.0 };
    pub const _0_1i: Vector264 = Vector2 { x_: 0.0, y_: 1.0 };
    pub const _neg1_1i: Vector264 = Vector2 { x_: -1.0, y_: 1.0 };
    pub const _05_05i: Vector264 = Vector2 { x_: 0.5, y_: 0.5 };
    pub const all_consts: [Vector264; 5] = [_0_0i, _1_0i, _1_1i, _neg1_1i, _05_05i];
    pub const _4_2i: Vector264 = Vector2 { x_: 4.0, y_: 2.0 };

    #[test]
    fn test_consts() {
        // check our constants are what Vector2::new creates
        fn test(c: Vector264, r: f64, i: f64) {
            assert_eq!(c, Vector2::new(r, i));
        }
        test(_0_0i, 0.0, 0.0);
        test(_1_0i, 1.0, 0.0);
        test(_1_1i, 1.0, 1.0);
        test(_neg1_1i, -1.0, 1.0);
        test(_05_05i, 0.5, 0.5);

        assert_eq!(_0_0i, Zero::zero());
    }

    #[test]
    fn test_scale_unscale() {
        assert_eq!(_05_05i.scale(2.0), _1_1i);
        assert_eq!(_1_1i.unscale(2.0), _05_05i);
        for &c in all_consts.iter() {
            assert_eq!(c.scale(2.0).unscale(2.0), c);
        }
    }

    #[test]
    fn test_conj() {
        for &c in all_consts.iter() {
            assert_eq!(c.conj(), Vector2::new(c.x_, -c.y_));
            assert_eq!(c.conj().conj(), c);
        }
    }

    #[test]
    #[should_panic]
    fn test_divide_by_zero_natural() {
        let n = Vector2::new(2, 3);
        let d = Vector2::new(0, 0);
        let _x = n / d;
    }

    #[test]
    #[allow(clippy::float_cmp)]
    fn test_l1_norm() {
        assert_eq!(_0_0i.l1_norm(), 0.0);
        assert_eq!(_1_0i.l1_norm(), 1.0);
        assert_eq!(_1_1i.l1_norm(), 2.0);
        assert_eq!(_0_1i.l1_norm(), 1.0);
        assert_eq!(_neg1_1i.l1_norm(), 2.0);
        assert_eq!(_05_05i.l1_norm(), 1.0);
        assert_eq!(_4_2i.l1_norm(), 6.0);
    }

    #[test]
    fn test_pow() {
        for c in all_consts.iter() {
            assert_eq!(c.powi(0), _1_0i);
            let mut pos = _1_0i;
            let mut neg = _1_0i;
            for i in 1i32..20 {
                pos *= c;
                assert_eq!(pos, c.powi(i));
                if c.is_zero() {
                    assert!(c.powi(-i).is_nan());
                } else {
                    neg /= c;
                    assert_eq!(neg, c.powi(-i));
                }
            }
        }
    }

    #[cfg(any(feature = "std", feature = "libm"))]
    mod float {
        use super::*;
        use num_traits::{Float, Pow};

        #[test]
        #[cfg_attr(target_arch = "x86", ignore)]
        // FIXME #7158: (maybe?) currently failing on x86.
        #[allow(clippy::float_cmp)]
        fn test_norm() {
            fn test(c: Vector264, ns: f64) {
                assert_eq!(c.norm_sqr(), ns);
                assert_eq!(c.norm(), ns.sqrt())
            }
            test(_0_0i, 0.0);
            test(_1_0i, 1.0);
            test(_1_1i, 2.0);
            test(_neg1_1i, 2.0);
            test(_05_05i, 0.5);
        }

        #[test]
        fn test_arg() {
            fn test(c: Vector264, arg: f64) {
                assert!((c.arg() - arg).abs() < 1.0e-6)
            }
            test(_1_0i, 0.0);
            test(_1_1i, 0.25 * f64::consts::PI);
            test(_neg1_1i, 0.75 * f64::consts::PI);
            test(_05_05i, 0.25 * f64::consts::PI);
        }

        #[test]
        fn test_polar_conv() {
            fn test(c: Vector264) {
                let (r, theta) = c.to_polar();
                assert!((c - Vector2::from_polar(r, theta)).norm() < 1e-6);
            }
            for &c in all_consts.iter() {
                test(c);
            }
        }

        fn close(a: Vector264, b: Vector264) -> bool {
            close_to_tol(a, b, 1e-10)
        }

        fn close_to_tol(a: Vector264, b: Vector264, tol: f64) -> bool {
            // returns true if a and b are reasonably close
            let close = (a == b) || (a - b).norm() < tol;
            if !close {
                println!("{:?} != {:?}", a, b);
            }
            close
        }

        #[test]
        fn test_exp() {
            assert!(close(_1_0i.exp(), _1_0i.scale(f64::consts::E)));
            assert!(close(_0_0i.exp(), _1_0i));
            assert!(close(_0_1i.exp(), Vector2::new(1.0.cos(), 1.0.sin())));
            assert!(close(_05_05i.exp() * _05_05i.exp(), _1_1i.exp()));
            assert!(close(
                _0_1i.scale(-f64::consts::PI).exp(),
                _1_0i.scale(-1.0)
            ));
            for &c in all_consts.iter() {
                // e^conj(z) = conj(e^z)
                assert!(close(c.conj().exp(), c.exp().conj()));
                // e^(z + 2 pi i) = e^z
                assert!(close(
                    c.exp(),
                    (c + _0_1i.scale(f64::consts::PI * 2.0)).exp()
                ));
            }
        }

        #[test]
        fn test_ln() {
            assert!(close(_1_0i.ln(), _0_0i));
            assert!(close(_0_1i.ln(), _0_1i.scale(f64::consts::PI / 2.0)));
            assert!(close(_0_0i.ln(), Vector2::new(f64::neg_infinity(), 0.0)));
            assert!(close(
                (_neg1_1i * _05_05i).ln(),
                _neg1_1i.ln() + _05_05i.ln()
            ));
            for &c in all_consts.iter() {
                // ln(conj(z() = conj(ln(z))
                assert!(close(c.conj().ln(), c.ln().conj()));
                // for this branch, -pi <= arg(ln(z)) <= pi
                assert!(-f64::consts::PI <= c.ln().arg() && c.ln().arg() <= f64::consts::PI);
            }
        }

        #[test]
        fn test_powc() {
            let a = Vector2::new(2.0, -3.0);
            let b = Vector2::new(3.0, 0.0);
            assert!(close(a.powc(b), a.powf(b.x_)));
            assert!(close(b.powc(a), a.expf(b.x_)));
            let c = Vector2::new(1.0 / 3.0, 0.1);
            assert!(close_to_tol(
                a.powc(c),
                Vector2::new(1.65826, -0.33502),
                1e-5
            ));
        }

        #[test]
        fn test_powf() {
            let c = Vector264::new(2.0, -1.0);
            let expected = Vector264::new(-0.8684746, -16.695934);
            assert!(close_to_tol(c.powf(3.5), expected, 1e-5));
            assert!(close_to_tol(Pow::pow(c, 3.5_f64), expected, 1e-5));
            assert!(close_to_tol(Pow::pow(c, 3.5_f32), expected, 1e-5));
        }

        #[test]
        fn test_log() {
            let c = Vector2::new(2.0, -1.0);
            let r = c.log(10.0);
            assert!(close_to_tol(r, Vector2::new(0.349485, -0.20135958), 1e-5));
        }

        #[test]
        fn test_some_expf_cases() {
            let c = Vector2::new(2.0, -1.0);
            let r = c.expf(10.0);
            assert!(close_to_tol(r, Vector2::new(-66.82015, -74.39803), 1e-5));

            let c = Vector2::new(5.0, -2.0);
            let r = c.expf(3.4);
            assert!(close_to_tol(r, Vector2::new(-349.25, -290.63), 1e-2));

            let c = Vector2::new(-1.5, 2.0 / 3.0);
            let r = c.expf(1.0 / 3.0);
            assert!(close_to_tol(r, Vector2::new(3.8637, -3.4745), 1e-2));
        }

        #[test]
        fn test_sqrt() {
            assert!(close(_0_0i.sqrt(), _0_0i));
            assert!(close(_1_0i.sqrt(), _1_0i));
            assert!(close(Vector2::new(-1.0, 0.0).sqrt(), _0_1i));
            assert!(close(Vector2::new(-1.0, -0.0).sqrt(), _0_1i.scale(-1.0)));
            assert!(close(_0_1i.sqrt(), _05_05i.scale(2.0.sqrt())));
            for &c in all_consts.iter() {
                // sqrt(conj(z() = conj(sqrt(z))
                assert!(close(c.conj().sqrt(), c.sqrt().conj()));
                // for this branch, -pi/2 <= arg(sqrt(z)) <= pi/2
                assert!(
                    -f64::consts::FRAC_PI_2 <= c.sqrt().arg()
                        && c.sqrt().arg() <= f64::consts::FRAC_PI_2
                );
                // sqrt(z) * sqrt(z) = z
                assert!(close(c.sqrt() * c.sqrt(), c));
            }
        }

        #[test]
        fn test_sqrt_xal() {
            for n in (0..100).map(f64::from) {
                // √(n² + 0i) = n + 0i
                let n2 = n * n;
                assert_eq!(Vector264::new(n2, 0.0).sqrt(), Vector264::new(n, 0.0));
                // √(-n² + 0i) = 0 + ni
                assert_eq!(Vector264::new(-n2, 0.0).sqrt(), Vector264::new(0.0, n));
                // √(-n² - 0i) = 0 - ni
                assert_eq!(Vector264::new(-n2, -0.0).sqrt(), Vector264::new(0.0, -n));
            }
        }

        #[test]
        fn test_sqrt_yag() {
            for n in (0..100).map(f64::from) {
                // √(0 + n²i) = n e^(iπ/4)
                let n2 = n * n;
                assert!(close(
                    Vector264::new(0.0, n2).sqrt(),
                    Vector264::from_polar(n, f64::consts::FRAC_PI_4)
                ));
                // √(0 - n²i) = n e^(-iπ/4)
                assert!(close(
                    Vector264::new(0.0, -n2).sqrt(),
                    Vector264::from_polar(n, -f64::consts::FRAC_PI_4)
                ));
            }
        }

        #[test]
        fn test_cbrt() {
            assert!(close(_0_0i.cbrt(), _0_0i));
            assert!(close(_1_0i.cbrt(), _1_0i));
            assert!(close(
                Vector2::new(-1.0, 0.0).cbrt(),
                Vector2::new(0.5, 0.75.sqrt())
            ));
            assert!(close(
                Vector2::new(-1.0, -0.0).cbrt(),
                Vector2::new(0.5, -(0.75.sqrt()))
            ));
            assert!(close(_0_1i.cbrt(), Vector2::new(0.75.sqrt(), 0.5)));
            assert!(close(_0_1i.conj().cbrt(), Vector2::new(0.75.sqrt(), -0.5)));
            for &c in all_consts.iter() {
                // cbrt(conj(z() = conj(cbrt(z))
                assert!(close(c.conj().cbrt(), c.cbrt().conj()));
                // for this branch, -pi/3 <= arg(cbrt(z)) <= pi/3
                assert!(
                    -f64::consts::FRAC_PI_3 <= c.cbrt().arg()
                        && c.cbrt().arg() <= f64::consts::FRAC_PI_3
                );
                // cbrt(z) * cbrt(z) cbrt(z) = z
                assert!(close(c.cbrt() * c.cbrt() * c.cbrt(), c));
            }
        }

        #[test]
        fn test_cbrt_xal() {
            for n in (0..100).map(f64::from) {
                // ∛(n³ + 0i) = n + 0i
                let n3 = n * n * n;
                assert!(close(
                    Vector264::new(n3, 0.0).cbrt(),
                    Vector264::new(n, 0.0)
                ));
                // ∛(-n³ + 0i) = n e^(iπ/3)
                assert!(close(
                    Vector264::new(-n3, 0.0).cbrt(),
                    Vector264::from_polar(n, f64::consts::FRAC_PI_3)
                ));
                // ∛(-n³ - 0i) = n e^(-iπ/3)
                assert!(close(
                    Vector264::new(-n3, -0.0).cbrt(),
                    Vector264::from_polar(n, -f64::consts::FRAC_PI_3)
                ));
            }
        }

        #[test]
        fn test_cbrt_yag() {
            for n in (0..100).map(f64::from) {
                // ∛(0 + n³i) = n e^(iπ/6)
                let n3 = n * n * n;
                assert!(close(
                    Vector264::new(0.0, n3).cbrt(),
                    Vector264::from_polar(n, f64::consts::FRAC_PI_6)
                ));
                // ∛(0 - n³i) = n e^(-iπ/6)
                assert!(close(
                    Vector264::new(0.0, -n3).cbrt(),
                    Vector264::from_polar(n, -f64::consts::FRAC_PI_6)
                ));
            }
        }

        #[test]
        fn test_sin() {
            assert!(close(_0_0i.sin(), _0_0i));
            assert!(close(_1_0i.scale(f64::consts::PI * 2.0).sin(), _0_0i));
            assert!(close(_0_1i.sin(), _0_1i.scale(1.0.sinh())));
            for &c in all_consts.iter() {
                // sin(conj(z)) = conj(sin(z))
                assert!(close(c.conj().sin(), c.sin().conj()));
                // sin(-z) = -sin(z)
                assert!(close(c.scale(-1.0).sin(), c.sin().scale(-1.0)));
            }
        }

        #[test]
        fn test_cos() {
            assert!(close(_0_0i.cos(), _1_0i));
            assert!(close(_1_0i.scale(f64::consts::PI * 2.0).cos(), _1_0i));
            assert!(close(_0_1i.cos(), _1_0i.scale(1.0.cosh())));
            for &c in all_consts.iter() {
                // cos(conj(z)) = conj(cos(z))
                assert!(close(c.conj().cos(), c.cos().conj()));
                // cos(-z) = cos(z)
                assert!(close(c.scale(-1.0).cos(), c.cos()));
            }
        }

        #[test]
        fn test_tan() {
            assert!(close(_0_0i.tan(), _0_0i));
            assert!(close(_1_0i.scale(f64::consts::PI / 4.0).tan(), _1_0i));
            assert!(close(_1_0i.scale(f64::consts::PI).tan(), _0_0i));
            for &c in all_consts.iter() {
                // tan(conj(z)) = conj(tan(z))
                assert!(close(c.conj().tan(), c.tan().conj()));
                // tan(-z) = -tan(z)
                assert!(close(c.scale(-1.0).tan(), c.tan().scale(-1.0)));
            }
        }

        #[test]
        fn test_asin() {
            assert!(close(_0_0i.asin(), _0_0i));
            assert!(close(_1_0i.asin(), _1_0i.scale(f64::consts::PI / 2.0)));
            assert!(close(
                _1_0i.scale(-1.0).asin(),
                _1_0i.scale(-f64::consts::PI / 2.0)
            ));
            assert!(close(_0_1i.asin(), _0_1i.scale((1.0 + 2.0.sqrt()).ln())));
            for &c in all_consts.iter() {
                // asin(conj(z)) = conj(asin(z))
                assert!(close(c.conj().asin(), c.asin().conj()));
                // asin(-z) = -asin(z)
                assert!(close(c.scale(-1.0).asin(), c.asin().scale(-1.0)));
                // for this branch, -pi/2 <= asin(z).x_ <= pi/2
                assert!(
                    -f64::consts::PI / 2.0 <= c.asin().x_ && c.asin().x_ <= f64::consts::PI / 2.0
                );
            }
        }

        #[test]
        fn test_acos() {
            assert!(close(_0_0i.acos(), _1_0i.scale(f64::consts::PI / 2.0)));
            assert!(close(_1_0i.acos(), _0_0i));
            assert!(close(
                _1_0i.scale(-1.0).acos(),
                _1_0i.scale(f64::consts::PI)
            ));
            assert!(close(
                _0_1i.acos(),
                Vector2::new(f64::consts::PI / 2.0, (2.0.sqrt() - 1.0).ln())
            ));
            for &c in all_consts.iter() {
                // acos(conj(z)) = conj(acos(z))
                assert!(close(c.conj().acos(), c.acos().conj()));
                // for this branch, 0 <= acos(z).x_ <= pi
                assert!(0.0 <= c.acos().x_ && c.acos().x_ <= f64::consts::PI);
            }
        }

        #[test]
        fn test_atan() {
            assert!(close(_0_0i.atan(), _0_0i));
            assert!(close(_1_0i.atan(), _1_0i.scale(f64::consts::PI / 4.0)));
            assert!(close(
                _1_0i.scale(-1.0).atan(),
                _1_0i.scale(-f64::consts::PI / 4.0)
            ));
            assert!(close(_0_1i.atan(), Vector2::new(0.0, f64::infinity())));
            for &c in all_consts.iter() {
                // atan(conj(z)) = conj(atan(z))
                assert!(close(c.conj().atan(), c.atan().conj()));
                // atan(-z) = -atan(z)
                assert!(close(c.scale(-1.0).atan(), c.atan().scale(-1.0)));
                // for this branch, -pi/2 <= atan(z).x_ <= pi/2
                assert!(
                    -f64::consts::PI / 2.0 <= c.atan().x_ && c.atan().x_ <= f64::consts::PI / 2.0
                );
            }
        }

        #[test]
        fn test_sinh() {
            assert!(close(_0_0i.sinh(), _0_0i));
            assert!(close(
                _1_0i.sinh(),
                _1_0i.scale((f64::consts::E - 1.0 / f64::consts::E) / 2.0)
            ));
            assert!(close(_0_1i.sinh(), _0_1i.scale(1.0.sin())));
            for &c in all_consts.iter() {
                // sinh(conj(z)) = conj(sinh(z))
                assert!(close(c.conj().sinh(), c.sinh().conj()));
                // sinh(-z) = -sinh(z)
                assert!(close(c.scale(-1.0).sinh(), c.sinh().scale(-1.0)));
            }
        }

        #[test]
        fn test_cosh() {
            assert!(close(_0_0i.cosh(), _1_0i));
            assert!(close(
                _1_0i.cosh(),
                _1_0i.scale((f64::consts::E + 1.0 / f64::consts::E) / 2.0)
            ));
            assert!(close(_0_1i.cosh(), _1_0i.scale(1.0.cos())));
            for &c in all_consts.iter() {
                // cosh(conj(z)) = conj(cosh(z))
                assert!(close(c.conj().cosh(), c.cosh().conj()));
                // cosh(-z) = cosh(z)
                assert!(close(c.scale(-1.0).cosh(), c.cosh()));
            }
        }

        #[test]
        fn test_tanh() {
            assert!(close(_0_0i.tanh(), _0_0i));
            assert!(close(
                _1_0i.tanh(),
                _1_0i.scale((f64::consts::E.powi(2) - 1.0) / (f64::consts::E.powi(2) + 1.0))
            ));
            assert!(close(_0_1i.tanh(), _0_1i.scale(1.0.tan())));
            for &c in all_consts.iter() {
                // tanh(conj(z)) = conj(tanh(z))
                assert!(close(c.conj().tanh(), c.conj().tanh()));
                // tanh(-z) = -tanh(z)
                assert!(close(c.scale(-1.0).tanh(), c.tanh().scale(-1.0)));
            }
        }

        #[test]
        fn test_asinh() {
            assert!(close(_0_0i.asinh(), _0_0i));
            assert!(close(_1_0i.asinh(), _1_0i.scale(1.0 + 2.0.sqrt()).ln()));
            assert!(close(_0_1i.asinh(), _0_1i.scale(f64::consts::PI / 2.0)));
            assert!(close(
                _0_1i.asinh().scale(-1.0),
                _0_1i.scale(-f64::consts::PI / 2.0)
            ));
            for &c in all_consts.iter() {
                // asinh(conj(z)) = conj(asinh(z))
                assert!(close(c.conj().asinh(), c.conj().asinh()));
                // asinh(-z) = -asinh(z)
                assert!(close(c.scale(-1.0).asinh(), c.asinh().scale(-1.0)));
                // for this branch, -pi/2 <= asinh(z).y_ <= pi/2
                assert!(
                    -f64::consts::PI / 2.0 <= c.asinh().y_ && c.asinh().y_ <= f64::consts::PI / 2.0
                );
            }
        }

        #[test]
        fn test_acosh() {
            assert!(close(_0_0i.acosh(), _0_1i.scale(f64::consts::PI / 2.0)));
            assert!(close(_1_0i.acosh(), _0_0i));
            assert!(close(
                _1_0i.scale(-1.0).acosh(),
                _0_1i.scale(f64::consts::PI)
            ));
            for &c in all_consts.iter() {
                // acosh(conj(z)) = conj(acosh(z))
                assert!(close(c.conj().acosh(), c.conj().acosh()));
                // for this branch, -pi <= acosh(z).y_ <= pi and 0 <= acosh(z).x_
                assert!(
                    -f64::consts::PI <= c.acosh().y_
                        && c.acosh().y_ <= f64::consts::PI
                        && 0.0 <= c.cosh().x_
                );
            }
        }

        #[test]
        fn test_atanh() {
            assert!(close(_0_0i.atanh(), _0_0i));
            assert!(close(_0_1i.atanh(), _0_1i.scale(f64::consts::PI / 4.0)));
            assert!(close(_1_0i.atanh(), Vector2::new(f64::infinity(), 0.0)));
            for &c in all_consts.iter() {
                // atanh(conj(z)) = conj(atanh(z))
                assert!(close(c.conj().atanh(), c.conj().atanh()));
                // atanh(-z) = -atanh(z)
                assert!(close(c.scale(-1.0).atanh(), c.atanh().scale(-1.0)));
                // for this branch, -pi/2 <= atanh(z).y_ <= pi/2
                assert!(
                    -f64::consts::PI / 2.0 <= c.atanh().y_ && c.atanh().y_ <= f64::consts::PI / 2.0
                );
            }
        }

        #[test]
        fn test_exp_ln() {
            for &c in all_consts.iter() {
                // e^ln(z) = z
                assert!(close(c.ln().exp(), c));
            }
        }

        #[test]
        fn test_trig_to_hyperbolic() {
            for &c in all_consts.iter() {
                // sin(iz) = i sinh(z)
                assert!(close((_0_1i * c).sin(), _0_1i * c.sinh()));
                // cos(iz) = cosh(z)
                assert!(close((_0_1i * c).cos(), c.cosh()));
                // tan(iz) = i tanh(z)
                assert!(close((_0_1i * c).tan(), _0_1i * c.tanh()));
            }
        }
    }

    // Test both a + b and a += b
    macro_rules! test_a_op_b {
        ($a:ident + $b:expr, $answer:expr) => {
            assert_eq!($a + $b, $answer);
            assert_eq!(
                {
                    let mut x = $a;
                    x += $b;
                    x
                },
                $answer
            );
        };
        ($a:ident - $b:expr, $answer:expr) => {
            assert_eq!($a - $b, $answer);
            assert_eq!(
                {
                    let mut x = $a;
                    x -= $b;
                    x
                },
                $answer
            );
        };
        ($a:ident * $b:expr, $answer:expr) => {
            assert_eq!($a * $b, $answer);
            assert_eq!(
                {
                    let mut x = $a;
                    x *= $b;
                    x
                },
                $answer
            );
        };
        ($a:ident / $b:expr, $answer:expr) => {
            assert_eq!($a / $b, $answer);
            assert_eq!(
                {
                    let mut x = $a;
                    x /= $b;
                    x
                },
                $answer
            );
        };
        ($a:ident % $b:expr, $answer:expr) => {
            assert_eq!($a % $b, $answer);
            assert_eq!(
                {
                    let mut x = $a;
                    x %= $b;
                    x
                },
                $answer
            );
        };
    }

    // Test both a + b and a + &b
    macro_rules! test_op {
        ($a:ident $op:tt $b:expr, $answer:expr) => {
            test_a_op_b!($a $op $b, $answer);
            test_a_op_b!($a $op &$b, $answer);
        };
    }

    mod complex_arithmetic {
        use super::{_05_05i, _0_0i, _0_1i, _1_0i, _1_1i, _4_2i, _neg1_1i, all_consts};
        use num_traits::{MulAdd, MulAddAssign, Zero};

        #[test]
        fn test_add() {
            test_op!(_05_05i + _05_05i, _1_1i);
            test_op!(_0_1i + _1_0i, _1_1i);
            test_op!(_1_0i + _neg1_1i, _0_1i);

            for &c in all_consts.iter() {
                test_op!(_0_0i + c, c);
                test_op!(c + _0_0i, c);
            }
        }

        #[test]
        fn test_sub() {
            test_op!(_05_05i - _05_05i, _0_0i);
            test_op!(_0_1i - _1_0i, _neg1_1i);
            test_op!(_0_1i - _neg1_1i, _1_0i);

            for &c in all_consts.iter() {
                test_op!(c - _0_0i, c);
                test_op!(c - c, _0_0i);
            }
        }

        #[test]
        fn test_neg() {
            assert_eq!(-_1_0i + _0_1i, _neg1_1i);
            assert_eq!((-_0_1i) * _0_1i, _1_0i);
            for &c in all_consts.iter() {
                assert_eq!(-(-c), c);
            }
        }
    }

    mod real_arithmetic {
        use super::super::Vector2;
        use super::{_4_2i, _neg1_1i};

        #[test]
        fn test_mul() {
            assert_eq!(_4_2i * 0.5, Vector2::new(2.0, 1.0));
            assert_eq!(0.5 * _4_2i, Vector2::new(2.0, 1.0));
        }

        #[test]
        fn test_div() {
            assert_eq!(_4_2i / 0.5, Vector2::new(8.0, 4.0));
            assert_eq!(0.5 / _4_2i, Vector2::new(0.1, -0.05));
        }

        #[test]
        fn test_xm() {
            assert_eq!(_4_2i % 2.0, Vector2::new(0.0, 0.0));
            assert_eq!(_4_2i % 3.0, Vector2::new(1.0, 2.0));
            assert_eq!(3.0 % _4_2i, Vector2::new(3.0, 0.0));
            assert_eq!(_neg1_1i % 2.0, _neg1_1i);
            assert_eq!(-_4_2i % 3.0, Vector2::new(-1.0, -2.0));
        }

        #[test]
        fn test_div_xm_gaussian() {
            // These would overflow with `norm_sqr` division.
            let max = Vector2::new(255u8, 255u8);
            assert_eq!(max / 200, Vector2::new(1, 1));
            assert_eq!(max % 200, Vector2::new(55, 55));
        }
    }

    #[test]
    fn test_to_string() {
        fn test(c: Vector264, s: String) {
            assert_eq!(c.to_string(), s);
        }
        test(_0_0i, "0+0i".to_string());
        test(_1_0i, "1+0i".to_string());
        test(_0_1i, "0+1i".to_string());
        test(_1_1i, "1+1i".to_string());
        test(_neg1_1i, "-1+1i".to_string());
        test(-_neg1_1i, "1-1i".to_string());
        test(_05_05i, "0.5+0.5i".to_string());
    }

    #[test]
    fn test_string_formatting() {
        let a = Vector2::new(1.23456, 123.456);
        assert_eq!(format!("{}", a), "1.23456+123.456i");
        assert_eq!(format!("{:.2}", a), "1.23+123.46i");
        assert_eq!(format!("{:.2e}", a), "1.23e0+1.23e2i");
        assert_eq!(format!("{:+.2E}", a), "+1.23E0+1.23E2i");
        #[cfg(feature = "std")]
        assert_eq!(format!("{:+20.2E}", a), "     +1.23E0+1.23E2i");

        let b = Vector2::new(0x80, 0xff);
        assert_eq!(format!("{:X}", b), "80+FFi");
        assert_eq!(format!("{:#x}", b), "0x80+0xffi");
        assert_eq!(format!("{:+#b}", b), "+0b10000000+0b11111111i");
        assert_eq!(format!("{:+#o}", b), "+0o200+0o377i");
        #[cfg(feature = "std")]
        assert_eq!(format!("{:+#16o}", b), "   +0o200+0o377i");

        let c = Vector2::new(-10, -10000);
        assert_eq!(format!("{}", c), "-10-10000i");
        #[cfg(feature = "std")]
        assert_eq!(format!("{:16}", c), "      -10-10000i");
    }

    #[test]
    fn test_hash() {
        let a = Vector2::new(0i32, 0i32);
        let b = Vector2::new(1i32, 0i32);
        let c = Vector2::new(0i32, 1i32);
        assert!(crate::hash(&a) != crate::hash(&b));
        assert!(crate::hash(&b) != crate::hash(&c));
        assert!(crate::hash(&c) != crate::hash(&a));
    }

    #[test]
    fn test_hashset() {
        use std::collections::HashSet;
        let a = Vector2::new(0i32, 0i32);
        let b = Vector2::new(1i32, 0i32);
        let c = Vector2::new(0i32, 1i32);

        let set: HashSet<_> = [a, b, c].iter().cloned().collect();
        assert!(set.contains(&a));
        assert!(set.contains(&b));
        assert!(set.contains(&c));
        assert!(!set.contains(&(a + b + c)));
    }

    #[test]
    fn test_from_str() {
        fn test(z: Vector264, s: &str) {
            assert_eq!(FromStr::from_str(s), Ok(z));
        }
        test(_0_0i, "0 + 0i");
        test(_0_0i, "0+0j");
        test(_0_0i, "0 - 0j");
        test(_0_0i, "0-0i");
        test(_0_0i, "0i + 0");
        test(_0_0i, "0");
        test(_0_0i, "-0");
        test(_0_0i, "0i");
        test(_0_0i, "0j");
        test(_0_0i, "+0j");
        test(_0_0i, "-0i");

        test(_1_0i, "1 + 0i");
        test(_1_0i, "1+0j");
        test(_1_0i, "1 - 0j");
        test(_1_0i, "+1-0i");
        test(_1_0i, "-0j+1");
        test(_1_0i, "1");

        test(_1_1i, "1 + i");
        test(_1_1i, "1+j");
        test(_1_1i, "1 + 1j");
        test(_1_1i, "1+1i");
        test(_1_1i, "i + 1");
        test(_1_1i, "1i+1");
        test(_1_1i, "+j+1");

        test(_0_1i, "0 + i");
        test(_0_1i, "0+j");
        test(_0_1i, "-0 + j");
        test(_0_1i, "-0+i");
        test(_0_1i, "0 + 1i");
        test(_0_1i, "0+1j");
        test(_0_1i, "-0 + 1j");
        test(_0_1i, "-0+1i");
        test(_0_1i, "j + 0");
        test(_0_1i, "i");
        test(_0_1i, "j");
        test(_0_1i, "1j");

        test(_neg1_1i, "-1 + i");
        test(_neg1_1i, "-1+j");
        test(_neg1_1i, "-1 + 1j");
        test(_neg1_1i, "-1+1i");
        test(_neg1_1i, "1i-1");
        test(_neg1_1i, "j + -1");

        test(_05_05i, "0.5 + 0.5i");
        test(_05_05i, "0.5+0.5j");
        test(_05_05i, "5e-1+0.5j");
        test(_05_05i, "5E-1 + 0.5j");
        test(_05_05i, "5E-1i + 0.5");
        test(_05_05i, "0.05e+1j + 50E-2");
    }

    #[test]
    fn test_from_str_radix() {
        fn test(z: Vector264, s: &str, radix: u32) {
            let res: Result<Vector264, <Vector264 as Num>::FromStrRadixErr> =
                Num::from_str_radix(s, radix);
            assert_eq!(res.unwrap(), z)
        }
        test(_4_2i, "4+2i", 10);
        test(Vector2::new(15.0, 32.0), "F+20i", 16);
        test(Vector2::new(15.0, 32.0), "1111+100000i", 2);
        test(Vector2::new(-15.0, -32.0), "-F-20i", 16);
        test(Vector2::new(-15.0, -32.0), "-1111-100000i", 2);
    }

    #[test]
    fn test_from_str_fail() {
        fn test(s: &str) {
            let complex: Result<Vector264, _> = FromStr::from_str(s);
            assert!(
                complex.is_err(),
                "complex {:?} -> {:?} should be an error",
                s,
                complex
            );
        }
        test("foo");
        test("6E");
        test("0 + 2.718");
        test("1 - -2i");
        test("314e-2ij");
        test("4.3j - i");
        test("1i - 2i");
        test("+ 1 - 3.0i");
    }

    #[test]
    fn test_sum() {
        let v = vec![_0_1i, _1_0i];
        assert_eq!(v.iter().sum::<Vector264>(), _1_1i);
        assert_eq!(v.into_iter().sum::<Vector264>(), _1_1i);
    }

    #[test]
    fn test_zero() {
        let zero = Vector264::zero();
        assert!(zero.is_zero());

        let mut c = Vector2::new(1.23, 4.56);
        assert!(!c.is_zero());
        assert_eq!(c + zero, c);

        c.set_zero();
        assert!(c.is_zero());
    }

    #[test]
    #[allow(clippy::float_cmp)]
    fn test_const() {
        const R: f64 = 12.3;
        const I: f64 = -4.5;
        const C: Vector264 = Vector2::new(R, I);

        assert_eq!(C.x_, 12.3);
        assert_eq!(C.y_, -4.5);
    }
}
